{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#about-equinix-labs","title":"About Equinix Labs","text":"<p>Equinix Labs offers workshops, proof of concepts, and tools for exploring and bootstrapping Equinix digital infrastructure including Fabric, Metal, and Network Edge.</p>"},{"location":"#about-the-workshop","title":"About the workshop","text":"<p>Welcome to the second workshop in our Equinix Fabric Cloud Router and Pulumi series, where we delve deeper into the realm of multicloud connectivity. In this workshop, we'll continue our exploration of Pulumi's capabilities, showcasing its flexibility and extensibility across multiple clouds and languages.</p> <p>The goals of this workshop are:</p> <ul> <li>Swift Multicloud Connection Setup: We'll demonstrate how to rapidly establish a secure and efficient connection between Google Cloud Platform (GCP) and Amazon Web Services (AWS) using Equinix Fabric Cloud Router.</li> <li>Utilizing Custom Pulumi Components: You'll learn how to implement custom Pulumi Component Resources to enhance the functionality of cloud providers and streamline deployment workflows.</li> <li>Scalable Infrastructure Deployment: We'll emphasize the scalability and reusability of Pulumi resources, enabling you to seamlessly extend your infrastructure across diverse cloud environments.</li> <li>Real-world Application: Through hands-on examples, we'll showcase the practical application of Pulumi and Equinix Fabric in addressing real-world multicloud connectivity challenges.</li> </ul> <p>This workshop will be structured into several sections, each focusing on a specific aspect of configuring and deploying multicloud connections with Equinix Fabric Cloud Router and Pulumi. We'll provide detailed explanations, code snippets, and practical demonstrations to ensure a comprehensive learning experience.</p>"},{"location":"#workshop-agenda","title":"Workshop agenda","text":"<p>This workshop is split into four parts:</p> Part Title Duration 1 Setup 15 minutes 2 Fabric connection to AWS 15 minutes 3 Direct Connect configuration 10 minutes 4 Configuring Direct Connect to AWS VPC 10 minutes 5 Configuring BGP in Equinix Fabric 10 minutes 6 Deploying VM Instances in Both Clouds 10 minutes 7 Configuration and Provisioning 10 minutes 8 Testing Connectivity between GCP and AWS Instances 10 minutes 9 Conclusion 5 minutes"},{"location":"parts/conclusion/","title":"Conclusion","text":""},{"location":"parts/conclusion/#conclusion","title":"Conclusion","text":"<p>Congratulations on completing this workshop! Let's recap some of the key takeways that we've learned:</p> <ul> <li>We've expanded our expertise by integrating AWS into our infrastructure provisioning workflow alongside Equinix Fabric using Pulumi. This integration showcases the versatility and power of Pulumi in orchestrating multi-cloud environments.</li> <li>Through the creation of a multicloud environment utilizing Fabric Cloud Router, we've demonstrated the seamless connectivity between Google Cloud Platform (GCP) and Amazon Web Services (AWS), illustrating the potential for interconnected architectures across different cloud providers.</li> <li>By automating the end-to-end deployment process using Pulumi, we've enhanced our infrastructure deployment efficiency and reliability, laying the groundwork for scalable and repeatable infrastructure management practices.</li> </ul>"},{"location":"parts/conclusion/#next-steps","title":"Next Steps","text":"<p>As you continue your journey, consider exploring further possibilities with Pulumi and multicloud architectures. Here are some suggested next steps:</p> <ul> <li>Experiment with additional cloud providers and services to extend your multicloud environment. Integrate platforms like Microsoft Azure or other Equinix Fabric-supported clouds to diversify your infrastructure.</li> <li>Dive deeper into Pulumi's features and capabilities, exploring advanced deployment strategies, infrastructure as code best practices, and leveraging Pulumi's extensive ecosystem of libraries and integrations.</li> </ul>"},{"location":"parts/conclusion/#resources","title":"Resources","text":"<p>Here are a few other resources to look at to continue your Equinix platform journey:</p> <ul> <li>Deploy @ Equinix: A one-stop shop for blogs, guides, and plenty of other resources.</li> <li>Equinix Fabric Docs: Equinix Fabric official documentation.</li> <li>Equinix Labs: Provides SDKs and Pulumi modules for Infrastructure as Code tools.</li> <li>Equinix Community: A global community for customers and Equinix users.</li> </ul>"},{"location":"parts/part1_setup/","title":"1. Setup","text":""},{"location":"parts/part1_setup/#part-1-setup","title":"Part 1: Setup","text":"<p>To run this workshop you will need access to an Equinix Fabric Account or create a new one following steps below.</p> <p>Note:  You are responsible for the cost of resources created in your Equinix Fabric account while running this workshop.</p>"},{"location":"parts/part1_setup/#pre-requisites","title":"Pre-requisites","text":"<p>The following tools will be needed on your local development environment where you will be running most of the commands in this guide.</p> <ul> <li>pulumi</li> <li>python</li> <li>Optional (but recommended): Google Cloud CLI</li> </ul>"},{"location":"parts/part1_setup/#steps","title":"Steps","text":""},{"location":"parts/part1_setup/#1-complete-previous-workshop-setup-steps","title":"1. Complete previous workshop setup steps","text":"<p>To get started with this workshop, please ensure you have completed the setup steps outlined in the previous workshop, including the installation of the template, as we'll be working on it here. You can find detailed instructions in Part 1: Setup.</p>"},{"location":"parts/part1_setup/#2-configure-aws-credentials","title":"2. Configure AWS credentials","text":"<p>In addition to the setup steps from the previous workshop, you'll also need to configure your AWS credentials. Please follow the instructions provided in the AWS Provider Installation &amp; Configuration Guide to set up your AWS credentials.</p>"},{"location":"parts/part1_setup/#3-installing-aws-dependency","title":"3. Installing AWS dependency","text":"<p>Furthermore, ensure you have the AWS dependency installed by adding it to the <code>requirements.txt</code> file:</p> Text Only<pre><code>pulumi_aws&gt;=6.29.0\n</code></pre> <p>Then, run the following command to install the dependencies:</p> Bash<pre><code>pip install -r requirements.txt\n</code></pre> <p>Note: In this workshop, we utilize the classic provider for AWS instead of the native provider unlike GCP. This is because the Direct Connect resources are not yet available in the native provider.</p>"},{"location":"parts/part1_setup/#discussion","title":"Discussion","text":"<p>Before proceeding to the next part let's take a few minutes to discuss what we did. Here are some questions to start the discussion.</p> <ul> <li>How might the setup process differ when integrating additional cloud providers, such as Azure, into the existing infrastructure?</li> </ul>"},{"location":"parts/part2_fabric_connection_to_aws/","title":"2. Fabric connection to AWS","text":""},{"location":"parts/part2_fabric_connection_to_aws/#part-2-fabric-connection-to-aws","title":"Part 2: Fabric connection to AWS","text":"<p>In this section, we'll start by configuring the connection from Equinix Fabric to AWS. For now, we'll add the code in the <code>__main__.py</code> file, although later on, we'll separate some logic into other files for better readability and maintenance.</p>"},{"location":"parts/part2_fabric_connection_to_aws/#steps","title":"Steps","text":""},{"location":"parts/part2_fabric_connection_to_aws/#1-defining-required-config-parameters","title":"1. Defining required config parameters","text":"<p>We'll start by adding some configuration variables that we'll need later. Look for the <code>#Configuration</code> section at the beginning of the file and add them:</p> Python<pre><code>aws_account_id = config.require(\"awsAccountId\")\naws_region = config.get(\"awsRegion\") or \"eu-central-1\"\n</code></pre>"},{"location":"parts/part2_fabric_connection_to_aws/#2-configuring-connection-to-aws","title":"2. Configuring Connection to AWS","text":"<p>Then, we'll move to the end of the file to add the <code>equinix.fabric.Connection</code> resource and the <code>equinix.fabric.get_service_profiles</code> function that we'll use to obtain the ID of the service profile for AWS Direct Connect.</p> Python<pre><code># Service Profile lookup\naws_service_profile = equinix.fabric.get_service_profiles(\n    filter=equinix.fabric.GetServiceProfilesFilterArgs(\n        property=\"/name\",\n        operator=\"=\",\n        values=[\"AWS Direct Connect\"],\n    ),\n)\n\n# Fabric Connection creation\naws_fabric_connection = equinix.fabric.Connection(\"connectionToAWS\",\n    name=\"pulumi-demo-fcr-aws\",\n    type=\"IP_VC\",\n    notifications=[equinix.fabric.ConnectionNotificationArgs(\n        type=\"ALL\", emails=notification_emails)],\n    order=equinix.fabric.ConnectionOrderArgs(\n        purchase_order_number=purchase_order_num,\n    ),\n    bandwidth=speed_in_mbps,\n    redundancy=equinix.fabric.ConnectionRedundancyArgs(priority=\"PRIMARY\"),\n    a_side=equinix.fabric.ConnectionASideArgs(\n        access_point=equinix.fabric.ConnectionASideAccessPointArgs(\n            type=\"CLOUD_ROUTER\",\n            router=equinix.fabric.ConnectionASideAccessPointRouterArgs(\n                uuid=fabric_cloud_router.id\n            )\n        )\n    ),\n    z_side=equinix.fabric.ConnectionZSideArgs(\n        access_point=equinix.fabric.ConnectionZSideAccessPointArgs(\n            type=\"SP\",\n            authentication_key=aws_account_id,\n            seller_region=aws_region,\n            profile=equinix.fabric.ConnectionZSideAccessPointProfileArgs(\n                type=aws_service_profile.data[0].type,\n                uuid=aws_service_profile.data[0].uuid,\n            ),\n            location=equinix.fabric.ConnectionZSideAccessPointLocationArgs(\n                metro_code=equinix_metro,\n            ),\n        ),\n    ),\n    opts=pulumi.ResourceOptions(\n        depends_on=[fabric_cloud_router],\n        ignore_changes=[\"redundancy\", \"order\"]\n    ),\n)\n</code></pre> <p>It's important to note that in this case, we'll need to specify the AWS account ID in the <code>authentication_key</code>. Equinix will use it to create the request in that account, and it must be approved later from the AWS side</p>"},{"location":"parts/part3_configuring_direct_connect/","title":"3. Direct Connect configuration","text":""},{"location":"parts/part3_configuring_direct_connect/#part-3-direct-connect-configuration","title":"Part 3: Direct Connect configuration","text":"<p>In this part, we will extend our Pulumi template to configure Direct Connect on the AWS side. We'll create a custom Pulumi Component Resource to handle the setup, including accepting the connection, creating a Direct Connect Gateway, and setting up a private virtual interface.</p>"},{"location":"parts/part3_configuring_direct_connect/#steps","title":"Steps","text":""},{"location":"parts/part3_configuring_direct_connect/#1-organizing-the-code-in-a-separate-file","title":"1. Organizing the Code in a Separate File","text":"<p>To improve readability and facilitate code reuse, we'll create a new file in the root directory named <code>aws_dx.py</code> to contain the code for configuring Direct Connect on the AWS side. This will help keep our main Pulumi template file organized and focused on the overall infrastructure setup.</p>"},{"location":"parts/part3_configuring_direct_connect/#2-implementing-a-custom-pulumi-component-resource-for-aws","title":"2. Implementing a Custom Pulumi Component Resource for AWS","text":"<p>In this step, we'll create a Python class to implement a custom Pulumi Component Resource specifically for configuring Direct Connect on the AWS side (as we did with GCP). This resource will handle accepting the connection, creating a Direct Connect Gateway, and setting up a Private Virtual Interface, required to access an Amazon VPC using private IP addresses.</p> Python<pre><code>import pulumi\nimport pulumi_aws as aws\n\n# Class to set up AWS Direct Connect components\nclass AwsDirectConnectSetup(pulumi.ComponentResource):\n    def __init__(self, name, dx_connection_id, equinix_side_asn, amazon_side_asn, vlan, bgp_authkey=None, opts=None):\n        super().__init__('custom:resource:AwsDirectConnectSetup', name, None, opts)\n\n        # Accept Direct Connect connection\n        connection_confirmation = aws.directconnect.ConnectionConfirmation(f\"{name}-confirmation\",\n            connection_id=dx_connection_id,\n            opts=pulumi.ResourceOptions(parent=self)\n        )\n\n        # Create a Direct Connect Gateway\n        dx_gateway = aws.directconnect.Gateway(f\"{name}-gateway\",\n            amazon_side_asn=amazon_side_asn,\n            opts=pulumi.ResourceOptions(parent=self)\n        )\n\n        # Create a private virtual interface\n        private_vif = aws.directconnect.PrivateVirtualInterface(f\"{name}-private-vif\",\n            connection_id=connection_confirmation.connection_id,\n            vlan=vlan,\n            address_family=\"ipv4\",\n            bgp_asn=equinix_side_asn,\n            dx_gateway_id=dx_gateway.id,\n            bgp_auth_key=bgp_authkey,\n            # amazon_address=bgp_amazon_address,\n            # customer_address=equinix_side_address\n            opts=pulumi.ResourceOptions(parent=self)\n        )\n\n        # Expose the Direct Connect Gateway ID for other resources to reference\n        self.dx_gateway_id = dx_gateway.id\n\n        # Expose the IPv4 BGP peer addresses and BGP authentication key\n        self.private_vif_amazon_address = private_vif.amazon_address\n        self.private_vif_customer_address = private_vif.customer_address\n        self.private_vif_bgp_auth_key = private_vif.bgp_auth_key\n\n        self.register_outputs({})\n</code></pre> <p>Note: We could specify the IP addresses with the <code>amazon_address</code> and <code>customer_address</code> fields, but this time we omit it and AWS will generate them for us</p>"},{"location":"parts/part3_configuring_direct_connect/#3-instantiating-the-custom-component-resource","title":"3. Instantiating the Custom Component Resource","text":"<p>In our <code>__main__.py</code> pulumi template file, we'll instantiate the new class for AWS Direct Connect. We'll provide the necessary parameters, such as the Direct Connect connection ID, Equinix-side ASN, Amazon-side ASN, VLAN, and optional BGP authentication key, to configure the Direct Connect connection.</p> <p>First we will need to update the required imports, they should look like this:</p> Python<pre><code>import os\nimport sys\nimport pulumi\nimport pulumi_equinix as equinix\nfrom pulumi_google_native.compute import v1 as gcpcompute\n\nsys.path.insert(0, os.getcwd())\nfrom extended_gcp import CloudRouterPeerConfig\nimport aws_dx\nimport pulumi_aws as aws\n</code></pre> <p>Then, we'll move to the end of the file to configure the AWS provider and create an instance of the Direct Connect Setup class</p> Python<pre><code># Configure the default AWS provider\naws_provider = aws.Provider('aws-provider')\n\n# We will need some information from the fabric connection that we added previously.\n# in this case, we will need to use apply since it is an Output field where we receive\n# the information asynchronously\naccess_point = aws_fabric_connection.z_side.apply(\n    lambda z_side: z_side[\"access_point\"]\n)\n\n# Create an instance of the Direct Connect Setup class\ndx_setup = aws_dx.AwsDirectConnectSetup('my-dx-setup',\n    dx_connection_id=access_point[\"provider_connection_id\"],\n    equinix_side_asn=fabric_cloud_router.equinix_asn,\n    amazon_side_asn='64512', # default Amazon ASN\n    vlan=access_point[\"link_protocol\"][\"vlan_tag\"],\n    opts=pulumi.ResourceOptions(\n        depends_on=[aws_fabric_connection],\n        provider=aws_provider\n    )\n)\n</code></pre>"},{"location":"parts/part4_connecting_to_a_vpc/","title":"4. Configuring Direct Connect to AWS VPC","text":""},{"location":"parts/part4_connecting_to_a_vpc/#part-4-configuring-direct-connect-to-aws-vpc","title":"Part 4: Configuring Direct Connect to AWS VPC","text":"<p>In this part, we will create a new Pulumi Component Resource class to handle the configuration of Direct Connect to an AWS VPC. This component will allow us to efficiently attach Direct Connect to multiple VPCs, enhancing the scalability and flexibility of our infrastructure setup.</p>"},{"location":"parts/part4_connecting_to_a_vpc/#steps","title":"Steps","text":""},{"location":"parts/part4_connecting_to_a_vpc/#1-implementing-a-new-custom-pulumi-component-resource-for-vpc-attachment","title":"1. Implementing a new Custom Pulumi Component Resource for VPC attachment","text":"<p>Back to our <code>aws_dx.py</code> file, we'll create a new Python class called <code>DirectConnectVPCAttachment</code>. This class will encapsulate the logic for setting up Direct Connect to an AWS VPC, including the creation of VPN gateways, gateway route propagation and association.</p> Python<pre><code># Class to connect Direct Connect Gateway to a VPC\nclass AwsDirectConnectVpcAttachment(pulumi.ComponentResource):\n\n    def __init__(self, name, vpc_id, dx_gateway_id, route_table_id, opts=None):\n        super().__init__('custom:resource:AwsDirectConnectVpcAttachment', name, None, opts)\n\n        # Create a new VPN Gateway and attach it to the VPC\n        vpn_gateway = aws.ec2.VpnGateway(f\"{name}-vpn-gateway\",\n            vpc_id=vpc_id,\n            opts=pulumi.ResourceOptions(parent=self)\n        )\n\n        # Automatic route propagation between the VPN gateway and the route table of the VPC\n        aws.ec2.VpnGatewayRoutePropagation(f\"{name}-route-propagation\",\n            vpn_gateway_id=vpn_gateway.id,\n            route_table_id=route_table_id,\n            opts=pulumi.ResourceOptions(parent=self)\n        )\n\n        # Associate the Direct Connect Gateway with the VPN Gateway\n        aws.directconnect.GatewayAssociation(f\"{name}-association\",\n            dx_gateway_id=dx_gateway_id,\n            associated_gateway_id=vpn_gateway.id,\n            opts=pulumi.ResourceOptions(parent=self)\n        )\n\n        # Expose the VPN Gateway ID for other resources to reference\n        self.vpn_gateway_id = vpn_gateway.id\n\n        self.register_outputs({})\n</code></pre> <p>By encapsulating this logic within a reusable component, we can easily attach Direct Connect to multiple VPCs as needed.</p>"},{"location":"parts/part4_connecting_to_a_vpc/#2-instantiating-the-custom-component-resource","title":"2. Instantiating the Custom Component Resource","text":"<p>In our <code>__main__.py</code> pulumi template file, we'll instantiate the new class We'll provide the necessary parameters, such as the VPC ID, Direct Connect Gateway ID, and the Route Table ID.</p> Python<pre><code># If no default VPC exists, the provider creates a new default VPC\nvpc_default = aws.ec2.DefaultVpc(\"default\", \n    tags={\n        \"Name\": \"Default VPC\"\n    }\n)\n\n# Create an instance of the Direct Connect VPC attachment using the VPC ID\ndx_vpc_attachment = aws_dx.AwsDirectConnectVpcAttachment('my-dx-vpc-attachment',\n    vpc_id=vpc_default.id,\n    dx_gateway_id=dx_setup.dx_gateway_id,\n    route_table_id=vpc_default.default_route_table_id,\n    opts=pulumi.ResourceOptions(\n        provider=aws_provider\n    )\n)\n</code></pre> <p>Note: For this example we have used <code>aws.ec2.DefaultVpc</code>, This resource has special caveats to be aware of when using it. if a default VPC exists, this provider does not create this resource, but instead \u201cadopts\u201d it into management. If no default VPC exists, the provider creates a new default VPC. Please read the documentation before using this resource.</p>"},{"location":"parts/part5_configuring_bgp/","title":"5. Configuring BGP in Equinix Fabric","text":""},{"location":"parts/part5_configuring_bgp/#part-5-configuring-bgp-in-equinix-fabric","title":"Part 5: Configuring BGP in Equinix Fabric","text":"<p>In this section, we will add the necessary code to configure BGP (Border Gateway Protocol) in the Equinix Fabric side. This configuration will establish the routing protocol for directing traffic between Equinix Fabric and AWS.</p>"},{"location":"parts/part5_configuring_bgp/#steps","title":"Steps","text":""},{"location":"parts/part5_configuring_bgp/#1-configuring-routing-protocol","title":"1. Configuring Routing Protocol","text":"<p>In this step, we'll configure the direct routing protocol for the AWS connection in the Equinix Fabric side. This protocol specifies the direct routing path for traffic between Equinix Fabric and AWS.</p> Python<pre><code># Configure BGP in Equinix Fabric side\naws_routing_protocol_direct = equinix.fabric.RoutingProtocol(\"AWSRoutingProtocolDirect\",\n    name=\"FabricToAWSRoutingProtocolDirect\",\n    type=\"DIRECT\",\n    connection_uuid=aws_fabric_connection.id,\n    direct_ipv4=equinix.fabric.RoutingProtocolDirectIpv4Args(\n        equinix_iface_ip= dx_setup.private_vif_customer_address\n    ),\n    opts=pulumi.ResourceOptions(\n        ignore_changes=[\"name\"]\n    ),\n)\n</code></pre>"},{"location":"parts/part5_configuring_bgp/#2-configuring-bgp-routing-protocol-for-aws-connection","title":"2. Configuring BGP Routing Protocol for AWS Connection","text":"<p>Next, we'll configure the BGP routing protocol for the AWS connection in the Equinix Fabric side. This protocol defines the rules and procedures for exchanging routing information between Equinix Fabric and AWS.</p> Python<pre><code>customer_peer_ip = dx_setup.private_vif_amazon_address.apply(lambda s: s.split('/'))[0]\n\nrouting_protocol = equinix.fabric.RoutingProtocol(\"AWSRoutingProtocolBGP\",\n    connection_uuid=aws_fabric_connection.id,\n    name=\"FabricToAWSRoutingProtocol\",\n    type=\"BGP\",\n    customer_asn='64512',\n    bgp_ipv4=equinix.fabric.RoutingProtocolBgpIpv4Args(\n        customer_peer_ip=customer_peer_ip\n    ),\n    bgp_auth_key=dx_setup.private_vif_bgp_auth_key,\n    opts=pulumi.ResourceOptions(\n        depends_on=[aws_routing_protocol_direct],\n        ignore_changes=[\"name\"]\n    ),\n)\n</code></pre> <p>Note: unlike the <code>equinix_iface_ip</code> the <code>customer_peer_ip</code> cannot be a cidr notation and we need to remove the subnet mask from the string</p> <p>By following these steps, we'll successfully configure BGP in the Equinix Fabric side, enabling efficient routing of traffic between Equinix Fabric and AWS.</p>"},{"location":"parts/part6_deploying_vm_instances/","title":"6. Deploying VM Instances in Both Clouds","text":""},{"location":"parts/part6_deploying_vm_instances/#part-6-deploying-vm-instances-in-both-clouds","title":"Part 6: Deploying VM Instances in Both Clouds","text":"<p>In this part, we'll deploy VM instances in both Google Cloud Platform (GCP) and Amazon Web Services (AWS), configuring firewall rules to allow private traffic between the respective VPCs and enabling SSH connections. This setup will demonstrate the private connection between the two clouds, allowing for seamless communication between resources.</p>"},{"location":"parts/part6_deploying_vm_instances/#steps","title":"Steps","text":""},{"location":"parts/part6_deploying_vm_instances/#1-deploying-vm-instances-in-google-cloud-platform-gcp","title":"1. Deploying VM Instances in Google Cloud Platform (GCP)","text":"<p>In this step, we'll deploy a VM instance in Google Cloud Platform (GCP) to demonstrate the private connection between GCP and AWS. Along with the VM, we'll configure firewall rules to allow traffic from the AWS VPC and enable SSH connections.</p> Python<pre><code># GCP Instance Configuration\ngcp_instance = gcpcompute.Instance('gcp-vm-instance',\n    project=gcp_project,\n    name='gcp-vm',\n    machine_type='e2-micro',\n    zone=f\"{gcp_region}-a\",\n    disks=[\n        gcpcompute.AttachedDiskArgs(\n            boot=True,\n            initialize_params=gcpcompute.AttachedDiskInitializeParamsArgs(\n                source_image=\"projects/debian-cloud/global/images/family/debian-11\",\n            )\n        ),\n    ],\n    network_interfaces=[gcpcompute.NetworkInterfaceArgs(\n        network=gcp_vpc_network.self_link,\n    )]\n)\n\n# GCP Firewall Rules\ngcpcompute.Firewall('gcp-firewall-rule-aws',\n    network=gcp_vpc_network.self_link,\n    allowed=[\n        gcpcompute.FirewallAllowedItemArgs(ip_protocol=\"tcp\", ports=[\"0-65535\"]),\n        gcpcompute.FirewallAllowedItemArgs(ip_protocol=\"udp\", ports=[\"0-65535\"]),\n        gcpcompute.FirewallAllowedItemArgs(ip_protocol=\"icmp\")\n    ],\n    source_ranges=[vpc_default.cidr_block], # CIDR block of the AWS VPC\n)\n\ngcpcompute.Firewall('gcp-firewall-rule-ssh',\n    network=gcp_vpc_network.self_link,\n    allowed=[\n        gcpcompute.FirewallAllowedItemArgs(ip_protocol=\"tcp\", ports=[\"0-65535\"]),\n        gcpcompute.FirewallAllowedItemArgs(ip_protocol=\"udp\", ports=[\"0-65535\"])\n    ],\n    source_ranges=[\"0.0.0.0/0\"],\n)\n</code></pre>"},{"location":"parts/part6_deploying_vm_instances/#2-deploying-vm-instances-in-amazon-web-services-aws","title":"2. Deploying VM Instances in Amazon Web Services (AWS)","text":"<p>Next, we'll deploy a VM instance in Amazon Web Services (AWS) to complement the connectivity demonstration. We'll set up a security group to allow traffic from the GCP VPC and enable SSH connections.</p> Python<pre><code># AWS Security Group Configuration\naws_security_group = aws.ec2.SecurityGroup('aws-security-group',\n    vpc_id=vpc_default.id,\n    ingress=[aws.ec2.SecurityGroupIngressArgs(\n            from_port=0,\n            to_port=0,\n            protocol='-1',  # `-1` indicates all protocols\n            cidr_blocks=[gcp_cidr_block],  # Block of the GCP VPC\n        ),\n        aws.ec2.SecurityGroupIngressArgs(\n            from_port=22,\n            to_port=22,\n            protocol='tcp',\n            cidr_blocks=[\"0.0.0.0/0\"], # Allows SSH connection\n        )],\n    egress=[aws.ec2.SecurityGroupEgressArgs(\n        from_port=0,\n        to_port=0,\n        protocol='-1',\n        cidr_blocks=[\"0.0.0.0/0\"], # Allows all outbound traffic\n    )]\n)\n\n# AWS EC2 Instance\naws_instance = aws.ec2.Instance('aws-vm-instance',\n    instance_type='t2.micro',\n    ami=pulumi.Output.all().apply(lambda args: get_ami_id(args)),\n    vpc_security_group_ids=[aws_security_group.id]\n)\n</code></pre> <p>Certainly! Here's the final step:</p>"},{"location":"parts/part6_deploying_vm_instances/#3-exporting-vm-instance-private-ips","title":"3. Exporting VM Instance Private IPs","text":"<p>Finally, we'll export the private IP addresses of both the GCP and AWS instances. With these exported values, we'll be able to ping each instance from the other once connected to each machine to demonstrate the interconnectivity between GCP and AWS.</p> Python<pre><code># Export GCP and AWS instance private IPs\npulumi.export('gcp_instance_private_ip', gcp_instance.network_interfaces[0].network_ip)\npulumi.export('aws_instance_private_ip', aws_instance.private_ip)\n</code></pre>"},{"location":"parts/part7_provisioning/","title":"7. Configuration and Provisioning","text":""},{"location":"parts/part7_provisioning/#part-7-configuration-and-provisioning","title":"Part 7: Configuration and Provisioning","text":""},{"location":"parts/part7_provisioning/#steps","title":"Steps","text":""},{"location":"parts/part7_provisioning/#1-create-a-yaml-file-with-the-required-configuration-parameters-for-our-pulumi-template","title":"1. Create a YAML file with the required configuration parameters for our Pulumi template","text":"<p>Before deploying our infrastructure, we need to define the necessary configuration parameters. These parameters might include authentication details, resource names, networking settings, and any other custom configurations required by our Pulumi template.</p> <p>You can use both the CLI and the programming model for your Pulumi configuration. The key-value pairs for any given stack are stored in your project\u2019s stack settings file, which is automatically named <code>Pulumi.&lt;stack-name&gt;.yaml</code>. This YAML file acts as the input for our deployment process, ensuring that our infrastructure is provisioned with the correct specifications.</p> <p>There are several parameters that must can be configured to use this template:</p> <ul> <li><code>accountNum</code> - (String) your Fabric account number</li> <li><code>projectId</code> - (String) your Fabric project UUID</li> <li><code>gcpProject</code> - (String) your Google Cloud project name</li> <li><code>notification_emails</code> - (Object) List of contact emails</li> <li><code>awsAccountId</code> - (String) your Fabric account number</li> <li><code>awsRegion</code> - (String) your AWS region. Used by the Equinix provider to create the Fabric connection to AWS</li> <li><code>aws:region</code> - (String) your AWS region. Used as a default value by the AWS provider so you don't need to define the region in each resource</li> </ul> <p>The command needed is <code>pulumi config set &lt;key&gt; [value]</code></p> Bash<pre><code>$ pulumi config set accountNum 1234\n$ pulumi config set projectId 5678\n$ pulumi config set gcpProject myGCPProject\n$ pulumi config set --path 'notification_emails[0]' example@equinix.com\n$ pulumi config set awsAccountId 000111222\n$ pulumi config set awsRegion eu-central-1\n$ pulumi config set aws:region eu-central-1\n</code></pre> <p>After that you will have a new file <code>Pulumi.&lt;stack-name&gt;.yaml</code> in your project. If for example your stack is called <code>equinixstack</code> and the project <code>workshop</code>, it will look like this:</p> Bash<pre><code>$ cat Pulumi.equinixstack.yaml\n\nconfig:\n  workshop:accountNum: \"1234\"\n  workshop:projectId: \"5678\"\n  workshop:gcpProject: myGCPProject\n  workshop:notification_emails:\n    - example@equinix.com\n  workshop:awsAccountId: \"000111222\"\n  workshop:awsRegion: eu-central-1\n  aws:region: eu-central-1\n</code></pre>"},{"location":"parts/part7_provisioning/#2-execute-pulumi-up-to-deploy-our-infrastructure","title":"2. Execute pulumi up to deploy our infrastructure","text":"<p>Now that our project is configured and dependencies are installed, we're ready to deploy our infrastructure using Pulumi. We'll execute the <code>pulumi up</code> command, which initiates the deployment process based on the configurations provided in our YAML file. Pulumi will orchestrate the creation of Equinix resources, establish connections with GCP, and configure the networking settings according to our specifications.</p> Bash<pre><code>$ pulumi up\n</code></pre>"},{"location":"parts/part7_provisioning/#4-verify-that-everything-is-configured-correctly-upon-deployment","title":"4. Verify that everything is configured correctly upon deployment","text":"<p>Upon completion of the deployment process, we'll validate that our infrastructure has been provisioned correctly. We'll use the Equinix portal to verify that all Equinix resources are created as expected, the connection to GCP and to AWS are established, and the Fabric Cloud Router configurations, including the BGP sessions, are properly configured. This validation step ensures that our infrastructure is ready for use and meets our desired specifications.</p>"},{"location":"parts/part8_testing_interconnection/","title":"8. Testing Connectivity between GCP and AWS Instances","text":""},{"location":"parts/part8_testing_interconnection/#part-8-testing-connectivity-between-gcp-and-aws-instances","title":"Part 8: Testing Connectivity between GCP and AWS Instances","text":"<p>In this final part, we'll test the connectivity between the VM instances deployed in Google Cloud Platform (GCP) and Amazon Web Services (AWS). We'll utilize the integrated SSH options provided by the AWS and GCP portals to connect to the instances and perform a ping using the private IP addresses.</p>"},{"location":"parts/part8_testing_interconnection/#steps","title":"Steps","text":""},{"location":"parts/part8_testing_interconnection/#1-connect-to-gcp-instance-via-ssh","title":"1. Connect to GCP Instance via SSH","text":"<ul> <li>Open the Google Cloud Platform (GCP) Console.</li> <li>Navigate to the Compute Engine section.</li> <li>Locate the GCP instance named <code>gcp-vm-instance</code>.</li> <li>Click on the SSH button next to the instance to open a terminal window.</li> </ul>"},{"location":"parts/part8_testing_interconnection/#2-connect-to-aws-instance-via-ssh","title":"2. Connect to AWS Instance via SSH","text":"<ul> <li>Open the Amazon Web Services (AWS) Management Console.</li> <li>Navigate to the EC2 Dashboard.</li> <li>Locate the AWS instance named <code>aws-vm-instance</code>.</li> <li>Select the instance and click on the Connect button.</li> <li>Follow the instructions to connect to the instance via SSH using the provided terminal command.</li> </ul>"},{"location":"parts/part8_testing_interconnection/#3-perform-ping-test","title":"3. Perform Ping Test","text":"<p>Once connected to both instances via SSH terminals, perform a ping test using the private IP addresses of the instances. Execute the following command in each terminal:</p> Bash<pre><code>ping &lt;private_ip_address_of_other_instance&gt;\n</code></pre> <p>Replace <code>&lt;private_ip_address_of_other_instance&gt;</code> with the private IP address of the instance in the other cloud.</p>"},{"location":"parts/part8_testing_interconnection/#4-verify-connectivity","title":"4. Verify Connectivity","text":"<p>Observe the ping responses to verify connectivity between the instances. Successful ping responses indicate that the private connection between Google Cloud Platform (GCP) and Amazon Web Services (AWS) is operational, allowing for seamless communication between the instances.</p> <p>By following these steps, we'll confirm the successful establishment of connectivity between the VM instances deployed in GCP and AWS, validating the effectiveness of the private interconnection setup.</p>"}]}